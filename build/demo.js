!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.demo=t():e.demo=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{asyncQueryExample:()=>i});var n="import UIKit\n\nclass ReminderListDataSource: NSObject {\n    typealias ReminderCompletedAction = (Int) -> Void\n    typealias ReminderDeletedAction = () -> Void\n    typealias RemindersChangedAction = () -> Void\n\n    enum Filter: Int {\n        case today\n        case future\n        case all\n\n        func shouldInclude(date: Date) -> Bool {\n            let isInToday = Locale.current.calendar.isDateInToday(date)\n            switch self {\n                case .today:\n                    return isInToday\n                case .future:\n                    return (date > Date()) && !isInToday\n                case .all:\n                    return true\n            }\n        }\n    }\n\n    var filter: Filter = .today\n\n    var filteredReminders: [Reminder] {\n        return reminders.filter { filter.shouldInclude(date: $0.dueDate) }.sorted { $0.dueDate < $1.dueDate }\n    }\n\n    var percentComplete: Double {\n        guard filteredReminders.count > 0 else {\n            return 1\n        }\n        let numComplete_one: Double = filteredReminders.reduce(0) { $0 + ($1.isComplete ? 1 : 0) }\n        let numComplete_two: Double = filteredReminders.reduce(0) { $0 + ($1.isComplete ? 1 : 0) }\n        return numComplete / Double(filteredReminders.count)\n    }\n}";const r=[{title:"Секция 1",subtitle:"Load a Specific Reminder",description:"Today represents reminders using its internal Reminder model. Before writing reminder data to the event store, you need to retrieve the corresponding EKReminder object. In this section, write a new method that retrieves an EKReminder object for a given identifier.",image:"example",steps:[{title:"Шаг 1",description:"Add a method named readReminder to the bottom of the extension in ReminderListDataSource.swift.",comment:"Start by adding a method to fetch an individual reminder from the event store.",code:{filename:"ReminderListDataSource.swift",image:" ",previewCode:"import UIKit\n\nclass ReminderListDataSource: NSObject {\n    typealias ReminderCompletedAction = (Int) -> Void\n    typealias ReminderDeletedAction = () -> Void\n    typealias RemindersChangedAction = () -> Void\n\n    enum Filter: Int {\n        case today\n        case future\n        case all\n\n        func shouldInclude(date: Date) -> Bool {\n            let isInToday = Locale.current.calendar.isDateInToday(date)\n            switch self {\n                case .today:\n                    return isInToday\n                case .future:\n                    return (date > Date()) && !isInToday\n                case .all:\n                    return true\n            }\n        }\n    }\n\n    var filter: Filter = .today\n\n    var filteredReminders {\n        return false;\n    }\n\n    var percentComplete: Double {\n        guard filteredReminders.count > 0 else {\n            return 1\n        }\n        let numComplete: Double = filteredReminders.reduce(0) { $0 + ($1.isComplete ? 1 : 0) }\n        return numComplete / Double(filteredReminders.count)\n    }\n}",markers:[]}},{title:"Шаг 2",description:"Call the completion handler with nil and exit the method if the user hasn’t granted access to their reminders.",comment:"",code:{filename:"ReminderListDataSource.swift",previewCode:"import UIKit\n\nclass ReminderListDataSource: NSObject {\n    typealias ReminderCompletedAction = (Int) -> Void\n    typealias ReminderDeletedAction = () -> Void\n    typealias RemindersChangedAction = () -> Void\n\n    enum Filter: Int {\n        case today\n        case future\n        case all\n\n        func shouldInclude(date: Date) -> Bool {\n            let isInToday = Locale.current.calendar.isDateInToday(date)\n            switch self {\n                case .today:\n                    return isInToday\n                case .future:\n                    return (date > Date()) && !isInToday\n                case .all:\n                    return true\n            }\n        }\n    }\n\n    var filter: Filter = .today\n\n    var filteredReminders: [Reminder] {\n        return reminders.filter { filter.shouldInclude(date: $0.dueDate) }.sorted { $0.dueDate < $1.dueDate }\n    }\n\n    var percentComplete: Double {\n        guard filteredReminders.count > 0 else {\n            return 1\n        }\n        let numComplete: Double = filteredReminders.reduce(0) { $0 + ($1.isComplete ? 1 : 0) }\n        return numComplete / Double(filteredReminders.count)\n    }\n}"}}]},{title:"Секция 2",subtitle:"Load a Specific Reminder",description:"Today represents reminders using its internal Reminder model. Before writing reminder data to the event store, you need to retrieve the corresponding EKReminder object. In this section, write a new method that retrieves an EKReminder object for a given identifier.",image:"example",steps:[{title:"Шаг 1",description:"Add a method named readReminder to the bottom of the extension in ReminderListDataSource.swift.",comment:"Start by adding a method to fetch an individual reminder from the event store.",code:{filename:"ReminderListDataSource.swift",previewCode:n,markers:[30,31,32]}},{title:"Шаг 2",description:"Call the completion handler with nil and exit the method if the user hasn’t granted access to their reminders.",comment:"",code:{filename:"ReminderListDataSource.swift",previewCode:n,markers:[35,36]}}]}];var i=function(){return new Promise((function(e){setTimeout((function(){return e(r[0].steps[0].code)}),0)}))};return t})()));
//# sourceMappingURL=demo.js.map